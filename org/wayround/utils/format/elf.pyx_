


def read_program_header_table(data, e_ident, elf_x_ehdr):

    x = e_ident['e_i_s_class']

    bits = None
    if x == 1:
        bits = 32
    elif x == 2:
        bits = 64
    else:
        raise ValueError("Wrong e_ident class")

    sections_data_size = elf_x_ehdr['e_phentsize'] * elf_x_ehdr['e_phnum']
    sections_data = data[elf_x_ehdr['e_phoff']:elf_x_ehdr['e_phoff'] + sections_data_size]

    sections = []
    for i in range(elf_x_ehdr['e_phnum']):

        index = i * elf_x_ehdr['e_phentsize']

        elf_x_phdr = None

        d = sections_data[index:index + elf_x_ehdr['e_phentsize']]

        if bits == 32:
            elf_x_phdr = elf32_phdr_to_dict(d)

        elif bits == 64:
            elf_x_phdr = elf64_phdr_to_dict(d)

        sections.append(elf_x_phdr)

    ret = sections

    return ret

def elf32_phdr_to_dict(data):

    cdef Elf32_Phdr Elf32_Phdr_i

    cdef unsigned char * data2

    data2 = data

    memcpy(& Elf32_Phdr_i, data2, sizeof(Elf32_Phdr))

    ret = Elf32_Phdr_i

    return ret


def elf64_phdr_to_dict(data):

    cdef Elf64_Phdr Elf64_Phdr_i

    cdef unsigned char * data2

    data2 = data

    memcpy(& Elf64_Phdr_i, data2, sizeof(Elf64_Phdr))

    ret = Elf64_Phdr_i

    return ret



def section_header_table_format(section_header_table, data, elf_x_ehdr):

    ret = ''


    names = []
    for i in range(len(section_header_table)):
        names.append(get_header_name(i, data, elf_x_ehdr, section_header_table))

    longest = 0
    for i in names:
        if len(i) > longest:
            longest = len(i)

    types = []
    for i in range(len(section_header_table)):
        types.append(get_section_header_type_name(section_header_table[i]['sh_type']))

    longest_t = 0
    for i in types:
        if len(i) > longest_t:
            longest_t = len(i)

    ret += "  [{index:2}] {name}(sto:{name_addr:5}) {typ} {addr:8} {off:8} {size:8} {es:2} {flg:10} {lk:3} {inf:3} {al:3}\n".format(
        index='No',
        name='Name'.ljust(longest),
        name_addr='',
        typ='Type'.ljust(longest_t),
        flg='Flags',
        addr='Address',
        off='Offset',
        size='Size',
        lk='Lnk',
        inf='Inf',
        al='Al',
        es='SZ'
        )


    for i in range(len(section_header_table)):
        ret += "  [{index:2}] {name}(sto:{name_addr:5x}) {typ} {addr:08x} {off:08x} {size:08x} {es:02x} {flg:010b} {lk:03x} {inf:03x} {al:03x}\n".format(
            index=i,
            name=str(names[i], encoding='utf-8').ljust(longest),
            name_addr=section_header_table[i]['sh_name'],
            typ=types[i].ljust(longest_t),
            flg=section_header_table[i]['sh_flags'],
            addr=section_header_table[i]['sh_addr'],
            off=section_header_table[i]['sh_offset'],
            size=section_header_table[i]['sh_size'],
            lk=section_header_table[i]['sh_link'],
            inf=section_header_table[i]['sh_info'],
            al=section_header_table[i]['sh_addralign'],
            es=section_header_table[i]['sh_entsize']
            )

    ret += '\n'
    ret += 'sto - string table offset\n'

    return ret

def program_header_table_format(program_header_table):

    ret = ''

    types = []
    for i in range(len(program_header_table)):
        types.append(get_program_header_type_name(program_header_table[i]['p_type']))

    longest_t = 0
    for i in types:
        if len(i) > longest_t:
            longest_t = len(i)

    ret += "  {typ} {offset:8} {virtaddr:8} {physaddr:8} {filesize:8} {memsize:8} {flag:10} {align:8}\n".format(
        typ='Type'.ljust(longest_t),
        flag='Flags',
        offset='F Offset',
        virtaddr='VirtAddr',
        physaddr='PhisAddr',
        filesize='FileSize',
        memsize='MemSize',
        align='Align'
        )

    for i in range(len(program_header_table)):
        ret += "  {typ} {offset:08x} {virtaddr:08x} {physaddr:08x} {filesize:08x} {memsize:08x} {flag:010b} {align:08x}\n".format(
            typ=types[i].ljust(longest_t),
            flag=program_header_table[i]['p_flags'],
            offset=program_header_table[i]['p_offset'],
            virtaddr=program_header_table[i]['p_vaddr'],
            physaddr=program_header_table[i]['p_paddr'],
            filesize=program_header_table[i]['p_filesz'],
            memsize=program_header_table[i]['p_memsz'],
            align=program_header_table[i]['p_align']
            )

    return ret

def copy_c_string(data, index):

    zero_index = index

    while True:

        if data[zero_index] == < char > 0:
            break

        zero_index += 1

    ret = data[index:zero_index]

    return ret

def get_header_name(index, data, elf_x_ehdr, section_header_table):

    ret = None

    if elf_x_ehdr['e_shstrndx'] != SHN_UNDEF:

        string_table_addr = section_header_table[elf_x_ehdr['e_shstrndx']]['sh_offset']

        ret = copy_c_string(data, string_table_addr + section_header_table[index]['sh_name'])

    return ret


#def read_dynamic_section(data, e_ident, elf_x_ehdr, section_header_table):
#
#    x = e_ident['e_i_s_class']
#
#    bits = None
#    if x == 1:
#        bits = 32
#    elif x == 2:
#        bits = 64
#    else:
#        raise ValueError("Wrong e_ident class")
#
#    dynamics = []
#
#    ind = get_section_header_index_by_name('.dynamic', data, elf_x_ehdr, section_header_table)
#
#    offset = section_header_table[ind]['sh_offset']
#
#    i = 0
#
#    while True:
#
#        if bits == 32:
#            ind = offset + (i * sizeof(Elf32_Dyn))
#            d = read_Elf32_Dyn(data, ind)
#
#        elif bits == 64:
#            ind = offset + (i * sizeof(Elf64_Dyn))
#            d = read_Elf64_Dyn(data)
#
#        if d['d_tag'] == DT_NULL:
#            break
#
#        dynamics.append(dynamics)
#
#    return dynamics


#def read_Elf32_Dyn(data, offset):
#
#    cdef Elf32_Dyn Elf32_Dyn_im
#
#    cdef unsigned char * data2
#
#    data3 = data[offset: offset + sizeof(Elf32_Dyn)]
#
#    data2 = data3
#
#    memcpy(& Elf32_Dyn_im, data2, sizeof(Elf32_Dyn))
#
##    ret = Elf32_Dyn_im
#
#    return ret

#def read_Elf64_Dyn(data, offset):
#
#    cdef Elf64_Dyn Elf64_Dyn_im
#
#    cdef unsigned char * data2
#
#    data3 = data[offset: offset + sizeof(Elf64_Dyn)]
#
#    data2 = data3
#
#    memcpy(& Elf64_Dyn_im, data2, sizeof(Elf64_Dyn))
#
##    ret = Elf64_Dyn_im
#
#    return ret

def get_section_header_index_by_name(name, data, elf_x_ehdr, section_header_table):

    ret = None
    for i in range(len(section_header_table)):
        n = get_header_name(i, data, elf_x_ehdr, section_header_table)

        if n == name:
            ret = i
            break

    return ret
